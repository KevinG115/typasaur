const { isValidTypescriptIdentifier, singularizeWord } = require("../utils");

function renderTypescriptFromTree({ rootTypeName, useInterfaceKeyword, rootTypeTree }) {
  const namedTypeDefinitions = [];
  const objectNodeToTypeName = new Map();
  const usedTypeNames = new Set([rootTypeName]);
  const typeKeyword = useInterfaceKeyword ? "interface" : "type";

  function nextAvailable(base) {
    if (!usedTypeNames.has(base)) { usedTypeNames.add(base); return base; }
    let n = 2; while (usedTypeNames.has(base + n)) n++;
    const finalName = base + n; usedTypeNames.add(finalName); return finalName;
  }
  function nameFromKey(jsonKey, isArrayItem = false) {
    const base = isArrayItem ? singularizeWord(jsonKey || "Item") : (jsonKey || "Model");
    return base[0].toUpperCase() + base.slice(1);
  }
  function ensureNamed(objectNode, jsonKey, isArrayItem = false) {
    if (objectNodeToTypeName.has(objectNode)) return objectNodeToTypeName.get(objectNode);
    const base = nameFromKey(jsonKey, isArrayItem);
    const finalName = nextAvailable(base);
    objectNodeToTypeName.set(objectNode, finalName);
    const body = renderNode(objectNode, jsonKey);
    namedTypeDefinitions.push(`export ${typeKeyword} ${finalName} = ${body};`);
    return finalName;
  }
  function renderArray(itemsNode, parentKey) {
    const inner = renderNode(itemsNode, parentKey, true);
    const needsParens = itemsNode.kind === "union" ||
      (itemsNode.kind === "string" && itemsNode.enumValues && itemsNode.enumValues.length > 0);
    return needsParens ? `(${inner})[]` : `${inner}[]`;
  }
  function renderNode(node, parentKey, inArray = false) {
    switch (node.kind) {
      case "any": return "any";
      case "number": return "number";
      case "boolean": return "boolean";
      case "string":
        if (node.enumValues && node.enumValues.length) {
          return node.enumValues.map(v => JSON.stringify(v)).join(" | ");
        }
        return node.isDate ? "string | Date" : "string";
      case "union":
        return node.types.map(t => renderNode(t, parentKey, inArray)).join(" | ");
      case "array":
        return renderArray(node.items, parentKey);
      case "object": {
        const lines = ["{"];
        const sorted = [...node.fields.entries()].sort(([a],[b]) => a.localeCompare(b));
        for (const [fieldName, fieldInfo] of sorted) {
          const opt = fieldInfo.required ? "" : "?";
          const safeKey = isValidTypescriptIdentifier(fieldName) ? fieldName : JSON.stringify(fieldName);
          let tsType;
          if (fieldInfo.type.kind === "object") {
            tsType = ensureNamed(fieldInfo.type, fieldName, false);
          } else if (fieldInfo.type.kind === "array" && fieldInfo.type.items.kind === "object") {
            const itemName = ensureNamed(fieldInfo.type.items, fieldName, true);
            tsType = `${itemName}[]`;
          } else if (fieldInfo.type.kind === "array") {
            tsType = renderArray(fieldInfo.type.items, fieldName);
          } else {
            tsType = renderNode(fieldInfo.type, fieldName);
          }
          lines.push(`  ${safeKey}${opt}: ${tsType};`);
        }
        lines.push("}");
        return lines.join("\n");
      }
    }
  }

  const header = `
/**
 * Generated by typasaur
 *
 *                    __
 *                   / _)
 *          .-^^^-/ /
 *      __/       /
 *     <__.|_|-|_|
 *
 * JSON to TypeScript Model CLI
 */
`.trim();

  const rootBody = renderNode(rootTypeTree, rootTypeName);
  const rootDecl = `export ${typeKeyword} ${rootTypeName} = ${rootBody};`;
  return [header, ...namedTypeDefinitions, rootDecl].join("\n\n") + "\n";
}

module.exports = { renderTypescriptFromTree };