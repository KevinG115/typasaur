import { TypeTree, TsRenderOptions } from "../types";

export function renderTypescriptFromTree(opts: {
  rootTypeName: string;
  rootTypeTree: TypeTree;
  useInterfaceKeyword: boolean;
  options?: TsRenderOptions;
}): string {
  const { rootTypeName, rootTypeTree, useInterfaceKeyword } = opts;
  const emitted = new Set<string>();
  const out: string[] = [];

  out.push(
    "/**",
    " * Generated by typasaur",
    " *",
    " *                    __",
    " *                   / _)",
    " *          .-^^^-/ /",
    " *      __/       /",
    " *     <__.|_|-|_|",
    " *",
    " * JSON to TypeScript Model CLI",
    " */",
    ""
  );

  emitNamed(rootTypeName, rootTypeTree, useInterfaceKeyword, emitted, out);
  return out.join("\n");
}

function emitNamed(
  name: string,
  tree: TypeTree,
  useInterface: boolean,
  emitted: Set<string>,
  out: string[]
) {
  if (emitted.has(name)) return;
  emitted.add(name);

  if (tree.kind !== "object") {
    out.push(`export type ${name} = ${tsType(tree, emitted, out, useInterface)};`, "");
    return;
  }

  out.push(`export ${useInterface ? "interface" : "type"} ${name} = {`);
  for (const [key, child] of Object.entries(tree.props)) {
    const fieldType = tsType(child, emitted, out, useInterface, key);
    out.push(`  ${key}: ${fieldType};`);
  }
  out.push("};", "");

  // Emit nested types after parent for readability.
  for (const [key, child] of Object.entries(tree.props)) {
    if (child.kind === "object") {
      emitNamed(toPascalCase(singularize(key)), child, useInterface, emitted, out);
    } else if (child.kind === "array" && child.element.kind === "object") {
      emitNamed(toPascalCase(singularize(key)), child.element, useInterface, emitted, out);
    } else if (child.kind === "union") {
      for (const opt of child.options) {
        if (opt.kind === "object") {
          emitNamed(toPascalCase(singularize(key)), opt, useInterface, emitted, out);
        } else if (opt.kind === "array" && opt.element.kind === "object") {
          emitNamed(toPascalCase(singularize(key)), opt.element, useInterface, emitted, out);
        }
      }
    }
  }
}

function tsType(
  node: TypeTree,
  emitted: Set<string>,
  out: string[],
  useInterface: boolean,
  hintName?: string
): string {
  switch (node.kind) {
    case "string":
      return "string";
    case "number":
      return "number";
    case "boolean":
      return "boolean";
    case "null":
      return "any";
    case "array":
      return `${tsType(node.element, emitted, out, useInterface, hintName)}[]`;
    case "object": {
      const name = node.name || (hintName ? toPascalCase(singularize(hintName)) : "Object");
      if (!emitted.has(name)) emitNamed(name, node, useInterface, emitted, out);
      return name;
    }
    case "union": {
      const parts = node.options.map((o) => tsType(o, emitted, out, useInterface, hintName));
      return [...new Set(parts)].join(" | ");
    }
    default: {
      const _exhaustive: never = node;
      return "any";
    }
  }
}

function toPascalCase(s: string) {
  return s.replace(/(^|[_\-\s]+)(\w)/g, (_, __, c: string) => c.toUpperCase());
}
function singularize(s: string) {
  return s.endsWith("s") && s.length > 1 ? s.slice(0, -1) : s;
}